---
title: 美团点评事业部笔试题
date: 2024-07-16 00:14:36
updated: 2024-07-16 00:14:36
tags: 
    - 面试
    - 笔试
categories: 面试
keywords:
description: 
top_img:
comments:
cover:
---


# 美团点评事业部笔试题

## 题目一

### 题目

编写一个java函数，实现获取1000个用户昵称的能力，具体要求如下：  1）提供一个函数Service.get(List userIds)，支持传入1000个用户ID，返回用 户ID及其对应的昵称  2）在Service.get 内部，通过调用UserService.getUserMap(List userIds)获取 数据，但UserService.getUserMap 每次最多只接收50个用户ID，且该接口一次请求耗时 100ms  3）Service.get(List userIds)函数需要将所有 1000 个传入的用户ID一次返回， 并且耗时需要保证在200ms以内。

### 解答

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class Service {

    // 一个批次内最多可接收数据量
    public static final int MAX_BATCH_SIZE = 50;
    // 最大超时时间
    public static final int TIMEOUT = 200;

    /**
     * 主要思路就是通过多线程的方式来并行获取数据
     */
    public Map<Long, String> get(List<Long> userIds) throws ExecutionException, InterruptedException, TimeoutException {
        int userCount = userIds.size();
        int batchCount = (int) Math.ceil((double) userCount / MAX_BATCH_SIZE);
        // 通过线程池来同时获取
        ExecutorService executor = Executors.newFixedThreadPool(batchCount);
        List<Future<Map<Long, String>>> futureList = new ArrayList<>();
        for (int i = 0; i < userCount; i += MAX_BATCH_SIZE) {
            List<Long> subList = userIds.subList(i, Math.min(i + MAX_BATCH_SIZE, userCount));
            futureList.add(executor.submit(() -> {
                UserService userService = new UserService();
                return userService.getUserMap(subList);
            }));
        }
        Map<Long, String> result = new HashMap<>();
        // 获取线程运行结果并放入结果集中
        for (Future<Map<Long, String>> future : futureList) {
            result.putAll(future.get(TIMEOUT, TimeUnit.MILLISECONDS));
        }
        executor.shutdown();
        return result;
    }

    /**
     * 主方法用于测试
     */
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        List<Long> userIds = new ArrayList<>();
        // 模拟1000个用户id
        for (long i = 1; i <= 1000; i++) {
            userIds.add(i);
        }
        Service service = new Service();
        long start = System.currentTimeMillis();
        Map<Long, String> userIdNameMap = service.get(userIds);
        long end = System.currentTimeMillis();
        System.out.println("get " + userIdNameMap.keySet().size() + " user nickname");
        System.out.println("used time:" + (end - start) + "ms");
    }
}

class UserService {

    public Map<Long, String> getUserMap(List<Long> userIds) throws InterruptedException {
        if (userIds == null || userIds.size() > 50) {
            throw new RuntimeException("userids more than 50");
        }
        Map<Long, String> result = new HashMap<>();
        for (Long userId : userIds) {
            result.put(userId, "test");
        }
        // 模拟接口耗时
        Thread.sleep(100);

        return result;
    }
}
```

### 运行结果截图

![image-20240715230055131](https://raw.githubusercontent.com/Simp1ezZz/pic_repository/main/image-20240715230055131.png)

---

## 题目二

### 题目 

设计一个Java缓存中间件系统，该中间件的缓存写入后，经过指定时间缓存要自动失效。 在读取缓存时，如果缓存不存在，需要异步调用 AService.get(K) 接口获取实时数据更新 到缓存中。

### 解答

```java
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CacheMiddleware<K, V> {

    private Map<K, V> cacheMap;
    private Map<K, Future<V>> futureMap;
    private ExecutorService executorService;
    private AService<K, V> aService;
    private long expirationTime; // 缓存过期时间，单位：毫秒
    private final Map<K, Long> expirationMap; // 存放每个缓存key的过期时间

    public CacheMiddleware(AService<K, V> aService, long expirationTime) {
        // 多线程访问的话使用线程安全的ConcurrentHashMap较好
        this.cacheMap = new ConcurrentHashMap<>();
        this.futureMap = new ConcurrentHashMap<>();
        this.executorService = Executors.newFixedThreadPool(10);
        this.aService = aService;
        this.expirationTime = expirationTime;
        this.expirationMap = new ConcurrentHashMap<>();
    }

    public V get(K key) {
        // 惰性删除 检查缓存是否过期，如果过期则删除
        if (expirationMap.containsKey(key) && System.currentTimeMillis() > expirationMap.get(key)) {
            cacheMap.remove(key);
            expirationMap.remove(key);
        }
        // 从缓存内获取
        V value = cacheMap.get(key);
        // 获取不到时调用接口获取
        if (value == null) {
            // 检查是否已经有线程正在获取了，没有就发起调用，有了就尝试直接从线程中获取返回结果
            Future<V> future = futureMap.get(key);
            if (future == null) {
                Callable<V> task = () -> aService.get(key);
                Future<V> futureTask = executorService.submit(task);
                futureMap.put(key, futureTask);
                try {
                    value = futureTask.get();
                    cacheMap.put(key, value);
                    scheduleExpiration(key);
                } catch (InterruptedException | ExecutionException e) {
                    futureMap.remove(key);
                    e.printStackTrace();
                }
            } else {
                try {
                    value = future.get();
                } catch (InterruptedException | ExecutionException e) {
                    futureMap.remove(key);
                    e.printStackTrace();
                }
            }
        }

        return value;
    }

    public void put(K key, V value) {
        // 放入缓存并设置过期时间
        cacheMap.put(key, value);
        scheduleExpiration(key);
    }

    public void remove(K key) {
        cacheMap.remove(key);
        expirationMap.remove(key);
        futureMap.remove(key);
    }

    /**
     * 这个更新方法参数只给了一个key，我理解是用来把缓存中的数据通过service来更新的 如果只是更新缓存的话直接调用put方法就可以了
     */
    public void update(K key) {
        executorService.submit(() -> {
            try {
                V value = aService.get(key);
                cacheMap.put(key, value);
                scheduleExpiration(key);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    private void scheduleExpiration(K key) {
        expirationMap.put(key, System.currentTimeMillis() + expirationTime);
    }

    /**
     * 主方法用来测试
     */
    public static void main(String[] args) throws InterruptedException {
        AService<String,String> aservice = new AServiceImpl();
        CacheMiddleware<String, String> cacheMiddleware = new CacheMiddleware<>(aservice,10000);
        cacheMiddleware.put("test1Key", "test1Value");
        cacheMiddleware.put("testExpirationKey","testExpirationValue");
        System.out.println(cacheMiddleware.get("test1Key"));
        System.out.println(cacheMiddleware.get("test2Key"));
        cacheMiddleware.update("test1Key");
        System.out.println(cacheMiddleware.get("test1Key"));
        cacheMiddleware.remove("test1Key");
        System.out.println(cacheMiddleware.get("test1Key"));
        Thread.sleep(10000);
        System.out.println(cacheMiddleware.get("testExpirationKey"));
    }
}

class AServiceImpl implements AService<String, String> {

    @Override
    public String get(String key) {
        System.out.println("AService get : " + key);
        return "test get " + key;
    }
}

interface AService<K, V> {

    V get(K key);
}
```

### 运行截图

![image-20240715234031836](https://raw.githubusercontent.com/Simp1ezZz/pic_repository/main/image-20240715234031836.png)

---

## 题目三

### 题目

设计一个用户头像展示器，在A页面展示尺寸为1*1的头像，在B页面展示尺寸为2*2的 头像。  1）已有函数 UserService.getUserPicWithTargetSize(int height, int width)，可以返 回尺寸为 height * width的头像url；  2）提供一个函数UserService.getUserPicForPage(int pageSource)，返回页面对应尺寸 的头像url;   3）不能用if-else 、三元表达式等条件控制语法来实现这个函数。

### 解答

```java
import java.util.HashMap;
import java.util.Map;

public class UserService {

    public static final int PAGE_SOURCE_A = 1;
    public static final int PAGE_SOURCE_B = 2;

    /**
     * 返回尺寸为 height * width的头像url 可直接使用
     */
    private static String getUserPicWithTargetSize(int height, int width) {
        return String.format("http://userpic_mock_h_%d_w_%d", height, width);
    }

    /**
     * 返回页面对应尺寸的头像url
     */
    private String getUserPicForPage(int pageSource) {
        // 可以采用策略模式来实现
        // sizeMap存储每个不同的策略，后续如果还需要有其他的可以直接添加不同的策略即可
        Map<Integer, Size> sizeMap = new HashMap<>();
        sizeMap.put(PAGE_SOURCE_A, new Size(1, 1));
        sizeMap.put(PAGE_SOURCE_B, new Size(2, 2));

        Size size = sizeMap.get(pageSource);
        if (size != null) {
            return getUserPicWithTargetSize(size.height, size.width);
        }
        throw new IllegalArgumentException("Invalid page source");
    }

    /**
     * 封装的图片大小的类，方便使用
     */
    private static class Size {
        int height;
        int width;

        Size(int height, int width) {
            this.height = height;
            this.width = width;
        }
    }

    public static void main(String[] args) {
        UserService userService = new UserService();
        System.out.println(userService.getUserPicForPage(UserService.PAGE_SOURCE_A));
        System.out.println(userService.getUserPicForPage(UserService.PAGE_SOURCE_B));
    }
}
```

### 运行截图

![image-20240715235331557](https://raw.githubusercontent.com/Simp1ezZz/pic_repository/main/image-20240715235331557.png)